#                    麦点甄选运营平台项目

麦点甄选运营平台项目,包含运营平台项目模板从0到1开发，以及数据大屏幕、权限等业务。

涉及技术栈包含***:vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts***等技术栈。

## 第一个重点:批量注册全局组件

```ts
import SvgIcon from './SvgIcon/index.vue'
import Pagination from './Pagination/index.vue'
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
// 全局对象
const allGlobalComponent = { SvgIcon, Pagination }

// 对外暴露插件对象
export default {
  //务必叫做install方法
  install(app) {
    Object.keys(allGlobalComponent).forEach((key) => {
      app.component(key, allGlobalComponent[key])
    })
    // 注册全部el-icon图标
    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
      app.component(key, component)
    }
  }
}
```

在入口文件中引入并注册

```ts
// 引入自定义插件对象：注册整个项目全局组件
import gloalComponents from "@/components";
// 注册自定义插件
app.use(gloalComponents);
```

## 第一个重点：路由鉴权

**路由鉴权**：鉴权，项目中路由能不能被访问的权限设置(某一个路由什么条件下可以访问，什么条件不能访问)

**需求**:注意用户是否登录，如果没登录不能去除了login页面以外的页面，并且带上之前想要去的页面路径，如果登录了就不能去login页面，如果去login页面就重定向到主页面，还需要注意用户登录之后需要发请求获取用户信息，如果拿不到用户信息说明token过期了，token过期了就需要清除用户以前的信息并跳转到登录页让用户重新登录

```ts
import router from '@/router'
router.beforeEach(async (to: any, from: any, next: any) => {
  nprogress.start()
  // 改变导航栏标题
  document.title=`${TITLE}`+`-${to.meta.title}`
  let token = LocalCache.getCache(LOGIN_TOKEN)
  let userState = useUserState()
  // 拿到用户信息
  let username = userState.username
  // 判断用户是否登录
  if (token) {
    // 用户登录了
    if (to.path == '/login') {
      // 登录了不能去登录页
      next('/home')
    } else {
      // 登录成功访问其他路由都可以
      // 是否存在用户信息
      if (!username) {
        try {
          // 发请求获取用户信息
          await userState.getUserInfo()
          next()
        } catch (error) {
          // 获取用户信息失败(也就是token过期)
          // 先退出登录
          await userState.userLogOut()
          next({path:'/login',query:{redirect:to.path}})
        }
      } else {
        // 存在则直接放行
        next()
      }
    }
  } else {
    // 用户未登录
    // 如果不是去登录页
    if (to.path != '/login') {
      // 将想要去的页面等到登录后重定向去
      next({ path: '/login', query: { redirect: to.path } })
    } else {
      next()
    }
  }
})
// 全局后置路由守卫
router.afterEach((to: any, from: any) => {
  nprogress.done()
})
```

> 需要注意很多细节问题，考虑要全面

## 第一个难点：对element-plus中的el-pagination分页器组件进行二次封装

原因:在项目中，如果每个列表页面都要写一遍分页方法，就会造成大量的代码冗余。所以需要进行二次封装来简化代码

**封装分页器的子组件**

```vue
<template>
  <div class="pagenation">
    <el-config-provider :locale="locale">
      <el-pagination
        v-model:current-page="paginationData.pageNo"
        v-model:page-size="paginationData.pageSize"
        :page-sizes="[3, 5, 10]"
        background
        layout=" prev, pager, next, jumper,->,sizes,total"
        :total="paginationData.total"
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
      />
    </el-config-provider>
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue'
import zhCn from 'element-plus/dist/locale/zh-cn.mjs'
import en from 'element-plus/dist/locale/en.mjs'
import { reactive } from 'vue';
// 使用中文语言
const language = ref('zh-cn')
const locale = computed(() => (language.value === 'zh-cn' ? zhCn : en))
// 接收父组件传过来的当前页数与每页数据条数以及总数据条数
const props = defineProps<{
  //总数据条数
  total:number,
  // 当前页数
  pageNo:number,
  // 每页数据条数
  pageSize:number
}>()
let paginationData=reactive({
  // 需要通过触发自定义事件带给父组件发送请求获取新页码对应的数据
  pageNo:props.pageNo,
  pageSize:props.pageSize,
  // 这里只父组件通过props传递一次total就行了，不需要通过触发自定义事件带给父组件
  // total:props.total
})
// 生成事件对象
const $emit = defineEmits(['change','update:pageSize','update:pageNo'])
// 改变每页数据条数
const handleSizeChange = (val: number) => {
  // 使用自定义事件实现父子组件数据同步
  $emit('update:pageSize',val)
  // 触发自定义事件获取对应当页指定条数的数据
  $emit('change',paginationData)
}
// 改变当前页数
const handleCurrentChange = (val: number) => {
  // 使用自定义事件实现父子组件数据同步
  $emit('update:pageNo',val)
  // 自定义事件获取对应页码的数据
  $emit('change',paginationData)
}
</script>

<style lang="scss" scoped></style>

```

父组件中使用

```vue
<template>
  <div class="trademark">
     <!-- 分页器 -->
     <Pagination 
       :total="20" 
       v-model:pageNo="pageNo" 
       v-model:pageSize="pageSize" 
       @change="handlerChangePage"
     ></Pagination>
  </div>
</template>

<script setup lang="ts">
import Pagination from '@/components/Pagination/index.vue'
import { reqProTrademarkList } from '@/api/product/index'
import { ref } from 'vue';
let pageNo = ref(1)
let pageSize = ref(3)
// 改变当前页数
const handlerChangePage=({pageNo,pageSize})=>{
  console.log(pageNo,pageSize);
  // 拿到子组件改变的page与pagesize后可以发送请求获取新页码对应数据
}
</script>

<style lang="scss" scoped></style>
```

## 第二个难点 为商品添加属性以及属性值的业务细节

```vue
<el-card v-if="scene == 1">
      <el-form :inline="true" ref="form">
        <el-form-item label="属性名称">
          <el-input placeholder="请输入属性名" v-model="attrParams.attrName"></el-input>
        </el-form-item>
      </el-form>
      <el-button
        :disabled="attrParams.attrName ? false : true"
        type="primary"
        icon="plus"
        @click="addAttrValue"
        >添加属性值</el-button
      >
      <!-- <el-button>取消</el-button> -->
      <el-table :data="attrParams.attrValueList" border style="margin: 10px 0">
        <el-table-column label="序号" type="index" width="55"></el-table-column>
        <el-table-column label="属性值">
          <template #default="{ row, $index }">
            <el-input
              v-if="row.flag"
              type="text"
              :ref="(vc:any)=>inputArr[$index]=vc"
              v-model.trim="row.valueName"
              placeholder="请输入属性值"
              @blur="toLook(row, $index)"
            />
            <div v-else @click="toEdit(row, $index)">{{ row.valueName }}</div>
          </template>
        </el-table-column>
        <el-table-column label="操作">
          <template #default="{ row, $index }">
            <el-button
              type="danger"
              icon="delete"
              size="small"
              @click="attrParams.attrValueList.splice($index, 1)"
            ></el-button>
          </template>
        </el-table-column>
      </el-table>
      <el-button
        type="primary"
        size="default"
        @click="saveNewAttr"
        :disabled="attrParams.attrValueList.length > 0 ? false : true"
        >保存</el-button
      >
      <el-button size="default" @click="scene = 0">取消</el-button>
    </el-card>
```

![](D:\小新\Screenshots\添加属性业务.png)

点击添加属性按钮在下面表格中要新增一个input框供用户输入属性值，输入完失焦后使input框变为div展示属性值(**编辑与展示切换**)

***思路***：将用户将要输入的属性值使用一个数组存储起来，点击一下添加按钮就向数组中push一个对象，对象中带有属性值与flag变量来标记当前为编辑模式还是展示模式

**具体实现**

```ts
<script setup lang='ts'>
// 商品属性列表数据
let attrList = ref<attrType[]>([])
// 属性对象
let attrParams = reactive<attrType>({
  //属性名
  attrName: '',
  categoryId: '',
  categoryLevel: 3,
  //属性值数组
  attrValueList: []
})
// 点击添加属性值的回调
const addAttrValue = () => {
  // 添加一个空对象让用户输入值
  attrParams.attrValueList.push({
    valueName: '',
    flag: true //控制input框与div框的切换
  })
  // 每次新添加一个input框时自动聚焦
  nextTick(() => {
    inputArr.value[attrParams.attrValueList.length - 1].focus()
  })
}
// 点击div的回调
const toEdit = (row: attrValType, $index: number) => {
  // 将div切换为input
  row.flag = true
  // 变为input自动获取焦点
  nextTick(() => {
    inputArr.value[$index].focus()
  })
}
</script>
```

第三个难点：怎样在el-form表单的表单项中的使用v-for遍历的多个下拉选择框收集为对象数组类型数据

```vue
//需要收集attrId以及attrValue
<el-form :inline="true">
  <el-form-item v-for="(attr, index) in attrList" :key="attr.id" :label="attr.attrName">
    <el-select placeholder="请选择">
      <el-option
        v-for="attrval in attr.attrValueList"
        :key="attrval.id"
        :label="attrval.valueName"
        :value="attrval.id"
      ></el-option>
    </el-select>
  </el-form-item>
</el-form>
```

思路：将选中的数据收集并挂载到数组中每个对象的自身，收集完到时候统一处理再带给服务器

```vue
<el-form :inline="true">
  <el-form-item v-for="(attr, index) in attrList" :key="attr.id" :label="attr.attrName">
      //在attr中添加一个属性attrIdAndAttrValueId用来存储收集到的每一个选择到的属性id以及属性值id
    <el-select v-model="attr.attrIdAndAttrValueId" placeholder="请选择">
      <el-option
        v-for="attrval in attr.attrValueList"
        :key="attrval.id"
        :label="attrval.valueName"
        :value="`${attr.id}:${attrval.id}`"
      ></el-option>
    </el-select>
  </el-form-item>
</el-form>

<script setup lang="ts">
//再统一处理加入到需要收集的skuAttrValueList字段的数组中
skuInfo.skuAttrValueList = attrList.value.reduce((prev: any, next: attrType) => {
    if (next.attrIdAndAttrValueId) {
      let [attrId, valueId] = next.attrIdAndAttrValueId.split(':')
      prev.push({ attrId, valueId })
    }
    return prev
  }, [])
</script>
```

